<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SlingCraft</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #0a0a0f; color: #ffffff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; display: flex; height: 100vh; }
        #game-canvas { flex: 1; display: block; }
        #info-panel { width: 280px; background-color: #1a1a24; padding: 20px; border-left: 1px solid #333; overflow-y: auto; }
        #info-panel h2 { margin-bottom: 15px; color: #88aaff; font-size: 18px; }
        #info-panel h3 { margin-top: 20px; margin-bottom: 10px; color: #aaaaaa; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
        .info-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
        .info-label { color: #888; }
        .info-value { color: #fff; font-family: monospace; }
        .energy-section { margin-top: 20px; padding-top: 15px; border-top: 1px solid #333; }
        .body-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
        #controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid #333; }
        button { background-color: #2a2a3a; color: #fff; border: 1px solid #444; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 8px; margin-bottom: 8px; font-size: 13px; }
        button:hover { background-color: #3a3a4a; }
        button.active { background-color: #4466aa; border-color: #5577bb; }
        .instructions { margin-top: 20px; padding-top: 15px; border-top: 1px solid #333; font-size: 12px; color: #666; line-height: 1.6; }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="info-panel">
        <h2>SlingCraft</h2>
        <div id="selected-body-info"><p style="color: #666; font-style: italic;">Click a body to select it</p></div>
        <div class="energy-section">
            <h3>System Energy</h3>
            <div class="info-row"><span class="info-label">Kinetic:</span><span class="info-value" id="kinetic-energy">0</span></div>
            <div class="info-row"><span class="info-label">Potential:</span><span class="info-value" id="potential-energy">0</span></div>
            <div class="info-row"><span class="info-label">Total:</span><span class="info-value" id="total-energy">0</span></div>
        </div>
        <div id="controls">
            <h3>Controls</h3>
            <button id="pause-btn">Pause</button>
            <button id="reset-btn">Reset</button>
        </div>
        <div class="instructions">
            <h3>Instructions</h3>
            <p>Click on a celestial body to select it and view its properties.</p>
            <p>The simulation shows gravitational interactions between bodies.</p>
        </div>
    </div>
    <script>
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const G = 50.0, MIN_DISTANCE = 10, DENSITY = 0.001;
let bodies = [], selectedBody = null, hoveredBody = null, isPaused = false, lastTime = 0;
let camera = { x: 0, y: 0, zoom: 1 };
let stars = [];

class CelestialBody {
    constructor(x, y, radius, color, name) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0;
        this.radius = radius; this.color = color; this.name = name;
        this.mass = DENSITY * (4/3) * Math.PI * Math.pow(radius, 3);
    }
    get kineticEnergy() { const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy); return 0.5 * this.mass * speed * speed; }
    get speed() { return Math.sqrt(this.vx*this.vx + this.vy*this.vy); }
}

function initBodies() {
    bodies = [];
    const central = new CelestialBody(0, 0, 80, '#ffaa44', 'Sol');
    central.mass = 1000;
    bodies.push(central);

    const body1 = new CelestialBody(200, 0, 25, '#4488ff', 'Terra');
    body1.mass = 50;
    body1.vy = Math.sqrt(G * central.mass / 200);
    bodies.push(body1);

    const body2 = new CelestialBody(-350, 0, 35, '#88ff88', 'Gaia');
    body2.mass = 80;
    body2.vy = -Math.sqrt(G * central.mass / 350);
    bodies.push(body2);

    const moon = new CelestialBody(200, -50, 10, '#aaaaaa', 'Luna');
    moon.mass = 5;
    moon.vx = -Math.sqrt(G * body1.mass / 50);
    moon.vy = body1.vy;
    bodies.push(moon);
}

function initStars() {
    stars = [];
    for (let i = 0; i < 200; i++) {
        stars.push({ x: Math.random()*2000-1000, y: Math.random()*2000-1000, brightness: Math.random()*0.5+0.2, size: Math.random()*1.5+0.5 });
    }
}

function calculateGravity(body, otherBodies) {
    let ax = 0, ay = 0;
    for (const other of otherBodies) {
        if (other === body) continue;
        const dx = other.x - body.x, dy = other.y - body.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const safeDist = Math.max(dist, MIN_DISTANCE);
        const acceleration = G * other.mass / (safeDist * safeDist);
        ax += acceleration * (dx / dist);
        ay += acceleration * (dy / dist);
    }
    return { ax, ay };
}

function calculateEnergies() {
    let kinetic = 0, potential = 0;
    for (const body of bodies) kinetic += body.kineticEnergy;
    for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {
            const dx = bodies[j].x - bodies[i].x, dy = bodies[j].y - bodies[i].y;
            potential -= G * bodies[i].mass * bodies[j].mass / Math.max(Math.sqrt(dx*dx + dy*dy), MIN_DISTANCE);
        }
    }
    return { kinetic, potential, total: kinetic + potential };
}

function calculateCenterOfMass() {
    let totalMass = 0, comX = 0, comY = 0;
    for (const body of bodies) { totalMass += body.mass; comX += body.x * body.mass; comY += body.y * body.mass; }
    return { x: comX / totalMass, y: comY / totalMass };
}

function updatePhysics(dt) {
    if (isPaused) return;
    dt = Math.min(dt, 0.033);
    const accelerations = bodies.map(body => calculateGravity(body, bodies));
    for (let i = 0; i < bodies.length; i++) {
        bodies[i].vx += accelerations[i].ax * dt;
        bodies[i].vy += accelerations[i].ay * dt;
        bodies[i].x += bodies[i].vx * dt;
        bodies[i].y += bodies[i].vy * dt;
    }
}

function worldToScreen(x, y) { return { x: (x - camera.x) * camera.zoom + canvas.width/2, y: (y - camera.y) * camera.zoom + canvas.height/2 }; }
function screenToWorld(sx, sy) { return { x: (sx - canvas.width/2) / camera.zoom + camera.x, y: (sy - canvas.height/2) / camera.zoom + camera.y }; }

function render() {
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const star of stars) {
        const screen = worldToScreen(star.x, star.y);
        ctx.fillStyle = `rgba(255,255,255,${star.brightness})`;
        ctx.beginPath(); ctx.arc(screen.x, screen.y, star.size, 0, Math.PI*2); ctx.fill();
    }

    const com = calculateCenterOfMass();
    const comScreen = worldToScreen(com.x, com.y);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath(); ctx.arc(comScreen.x, comScreen.y, 3, 0, Math.PI*2); ctx.fill();

    for (const body of bodies) {
        const screen = worldToScreen(body.x, body.y);
        const r = body.radius * camera.zoom;

        const gradient = ctx.createRadialGradient(screen.x, screen.y, r*0.5, screen.x, screen.y, r*2);
        gradient.addColorStop(0, body.color + '40');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath(); ctx.arc(screen.x, screen.y, r*2, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = body.color;
        ctx.beginPath(); ctx.arc(screen.x, screen.y, r, 0, Math.PI*2); ctx.fill();

        if (body === hoveredBody) {
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(screen.x, screen.y, r+5, 0, Math.PI*2); ctx.stroke();
        }
        if (body === selectedBody) {
            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
            ctx.beginPath(); ctx.arc(screen.x, screen.y, r+10, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]);
        }
        ctx.fillStyle = '#ffffff'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(body.name, screen.x, screen.y + r + 20);
    }
    updateInfoPanel();
}

function updateInfoPanel() {
    const energies = calculateEnergies();
    document.getElementById('kinetic-energy').textContent = energies.kinetic.toFixed(1);
    document.getElementById('potential-energy').textContent = energies.potential.toFixed(1);
    document.getElementById('total-energy').textContent = energies.total.toFixed(1);
    const infoDiv = document.getElementById('selected-body-info');
    if (selectedBody) {
        infoDiv.innerHTML = `<h3><span class="body-indicator" style="background-color:${selectedBody.color}"></span>${selectedBody.name}</h3>
            <div class="info-row"><span class="info-label">Mass:</span><span class="info-value">${selectedBody.mass.toFixed(1)}</span></div>
            <div class="info-row"><span class="info-label">Radius:</span><span class="info-value">${selectedBody.radius.toFixed(1)}</span></div>
            <div class="info-row"><span class="info-label">Position:</span><span class="info-value">(${selectedBody.x.toFixed(0)}, ${selectedBody.y.toFixed(0)})</span></div>
            <div class="info-row"><span class="info-label">Speed:</span><span class="info-value">${selectedBody.speed.toFixed(1)}</span></div>
            <div class="info-row"><span class="info-label">Kinetic E:</span><span class="info-value">${selectedBody.kineticEnergy.toFixed(1)}</span></div>`;
    } else {
        infoDiv.innerHTML = '<p style="color:#666;font-style:italic;">Click a body to select it</p>';
    }
}

function findBodyAtPosition(screenX, screenY) {
    const world = screenToWorld(screenX, screenY);
    for (const body of bodies) {
        const dx = world.x - body.x, dy = world.y - body.y;
        if (Math.sqrt(dx*dx + dy*dy) <= body.radius + 10) return body;
    }
    return null;
}

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    hoveredBody = findBodyAtPosition(e.clientX - rect.left, e.clientY - rect.top);
    canvas.style.cursor = hoveredBody ? 'pointer' : 'default';
});

canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    selectedBody = findBodyAtPosition(e.clientX - rect.left, e.clientY - rect.top);
});

function handleResize() {
    canvas.width = window.innerWidth - 280;
    canvas.height = window.innerHeight;
}

document.getElementById('pause-btn').addEventListener('click', () => {
    isPaused = !isPaused;
    document.getElementById('pause-btn').textContent = isPaused ? 'Resume' : 'Pause';
    document.getElementById('pause-btn').classList.toggle('active', isPaused);
});

document.getElementById('reset-btn').addEventListener('click', () => {
    initBodies(); selectedBody = null; hoveredBody = null; camera = { x: 0, y: 0, zoom: 1 };
});

function gameLoop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    updatePhysics(dt);
    render();
    requestAnimationFrame(gameLoop);
}

handleResize();
window.addEventListener('resize', handleResize);
initStars();
initBodies();
lastTime = performance.now();
requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
